<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 素材 2D 邏輯：鞋帶穿孔遊戲</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background-color: #0f172a; overflow: hidden; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; z-index: 10; }
        .mode-tag { display: inline-block; padding: 6px 16px; border-radius: 99px; background: #ef4444; color: white; font-weight: 800; font-size: 0.8rem; text-transform: uppercase; }
        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(15, 23, 42, 0.95); padding: 40px; border-radius: 20px;
            display: none; flex-direction: column; align-items: center; border: 2px solid #334155; z-index: 100; backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="statusTag" class="mode-tag mb-2">玩家操作</div>
        <div class="text-white text-6xl font-black italic tracking-tighter" id="score">0</div>
    </div>

    <div id="game-over">
        <h1 class="text-white text-5xl font-black mb-4 tracking-tighter text-center">GAME OVER</h1>
        <button onclick="location.reload()" class="px-10 py-4 bg-white text-black font-black rounded-full shadow-2xl uppercase tracking-widest">Restart</button>
    </div>

    <script>
        // --- Three.js 環境設定 ---
        const scene = new THREE.Scene();
        // 使用正交相機讓 3D 素材看起來像 2D 俯視角，但保留 3D 質感
        const aspect = window.innerWidth / window.innerHeight;
        const d = 25;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(0, 50, 0); // 從正上方俯看
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 燈光與材質 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 50, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 帆布背景平面
        const planeGeo = new THREE.PlaneGeometry(100, 100);
        const planeMat = new THREE.MeshStandardMaterial({ color: 0x253347, roughness: 1 });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // --- 遊戲邏輯變數 ---
        const boxSize = 4;
        let score = 0;
        let isAutoMode = false;
        let isGameOver = false;
        const speed = 200; // 統一速度

        let snake = [{ x: 0, y: 0 }];
        let direction = { x: 1, y: 0 };
        let targetHolePos = { x: 8, y: 8 };

        // 3D 素材
        let laceMeshes = [];
        const laceMaterial = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.5 });
        const eyeletMaterial = new THREE.MeshStandardMaterial({ color: 0x94a3b8, metalness: 0.8, roughness: 0.2 });

        // 鞋孔模型
        function createEyeletMesh(x, y) {
            const torusGeo = new THREE.TorusGeometry(1.8, 0.4, 12, 48);
            const torus = new THREE.Mesh(torusGeo, eyeletMaterial);
            torus.rotation.x = Math.PI / 2;
            torus.position.set(x, 0.1, y);
            scene.add(torus);
            return torus;
        }

        let targetEyelet = createEyeletMesh(targetHolePos.x, targetHolePos.y);

        // --- 核心邏輯 ---
        function update() {
            if (isGameOver) return;

            let head = { ...snake[0] };

            if (isAutoMode) {
                // 自動模式 (等速移動到新目標)
                if (head.x < targetHolePos.x) head.x += boxSize;
                else if (head.x > targetHolePos.x) head.x -= boxSize;
                else if (head.y < targetHolePos.y) head.y += boxSize;
                else if (head.y > targetHolePos.y) head.y -= boxSize;

                if (head.x === targetHolePos.x && head.y === targetHolePos.y) {
                    isAutoMode = false;
                    document.getElementById('statusTag').innerText = "玩家操作";
                    document.getElementById('statusTag').style.background = "#ef4444";
                    
                    // 隨機產生下一個孔
                    scene.remove(targetEyelet);
                    targetHolePos = {
                        x: (Math.floor(Math.random() * 8) - 4) * boxSize,
                        y: (Math.floor(Math.random() * 8) - 4) * boxSize
                    };
                    targetEyelet = createEyeletMesh(targetHolePos.x, targetHolePos.y);
                }
            } else {
                // 玩家操作
                head.x += direction.x * boxSize;
                head.y += direction.y * boxSize;

                // 邊界檢查
                if (Math.abs(head.x) > 30 || Math.abs(head.y) > 30) return endGame();

                // 進入孔洞檢查
                if (head.x === targetHolePos.x && head.y === targetHolePos.y) {
                    score++;
                    document.getElementById('score').innerText = score;
                    isAutoMode = true;
                    document.getElementById('statusTag').innerText = "地下穿梭";
                    document.getElementById('statusTag').style.background = "#3b82f6";
                }
            }

            snake.unshift(head);
            if (snake.length > 10) snake.pop();

            render3D();
        }

        function render3D() {
            laceMeshes.forEach(m => scene.remove(m));
            laceMeshes = [];

            snake.forEach((pos, i) => {
                // 如果是自動模式，身體部分隱藏 (模擬鑽入孔洞)
                // 只有頭部在自動模式移動時被繪製，達成消失效果
                if (isAutoMode && i > 0) return;

                const geo = new THREE.BoxGeometry(3.8, 1.5, 3.8);
                const mesh = new THREE.Mesh(geo, laceMaterial);
                mesh.position.set(pos.x, 0.75, pos.y);
                mesh.castShadow = true;
                scene.add(mesh);
                laceMeshes.push(mesh);
            });
        }

        function endGame() {
            isGameOver = true;
            document.getElementById('game-over').style.display = "flex";
        }

        // --- 控制 ---
        window.addEventListener('keydown', e => {
            if (isAutoMode) return;
            if (e.keyCode === 37 && direction.x === 0) direction = { x: -1, y: 0 }; // 左
            if (e.keyCode === 38 && direction.y === 0) direction = { x: 0, y: -1 }; // 上
            if (e.keyCode === 39 && direction.x === 0) direction = { x: 1, y: 0 };  // 右
            if (e.keyCode === 40 && direction.y === 0) direction = { x: 0, y: 1 };  // 下
        });

        // 啟動動畫
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        setInterval(update, speed);
        animate();

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
