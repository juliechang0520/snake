<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PAIHO 3D Snake - Professional Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root { --paiho-red: #D31A24; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #f1f5f9; position: fixed; }
        canvas { display: block; touch-action: none; }
        .joy-btn { 
            width: 60px; height: 60px; background: var(--paiho-red); 
            border-radius: 50%; color: white; display: flex; align-items: center; 
            justify-content: center; box-shadow: 0 4px 0 #900; transition: all 0.1s;
        }
        .joy-btn:active { transform: translateY(2px); box-shadow: 0 1px 0 #900; }
    </style>
</head>
<body class="flex flex-col">

<header class="h-14 flex items-center justify-between px-6 bg-white border-b border-slate-200 z-10">
    <span class="font-black text-slate-900 text-xl tracking-tighter">PAIHO <span class="text-red-600">SNAKE</span></span>
    <div class="bg-slate-50 px-4 py-1 rounded-full border border-slate-200 font-bold text-slate-700">
        SCORE: <span id="score-val">0</span>
    </div>
</header>

<div id="game-view" class="flex-1 relative bg-slate-100">
    <div id="over-mask" class="hidden absolute inset-0 bg-slate-900/60 backdrop-blur-sm flex items-center justify-center z-20">
        <div class="bg-white p-8 rounded-3xl text-center shadow-2xl">
            <h2 class="text-2xl font-black mb-4">GAME OVER</h2>
            <button onclick="resetGame()" class="bg-red-600 text-white px-10 py-3 rounded-full font-bold">RESTART</button>
        </div>
    </div>
</div>

<footer class="h-44 bg-[#d1d9e6] grid grid-cols-3 grid-rows-2 items-center justify-items-center p-4">
    <button class="joy-btn col-start-2" onpointerdown="handleInput(0, 1)">▲</button>
    <button class="joy-btn col-start-1 row-start-2" onpointerdown="handleInput(-1, 0)">◀</button>
    <button class="joy-btn col-start-2 row-start-2" onpointerdown="handleInput(0, -1)">▼</button>
    <button class="joy-btn col-start-3 row-start-2" onpointerdown="handleInput(1, 0)">▶</button>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, eyelet;
    let ropeParts = [];
    const state = {
        score: 0,
        status: 'PLAY',
        threadMode: 'down', // 'down' or 'up'
        headPos: new THREE.Vector3(0, 0.6, 0),
        currentDir: new THREE.Vector3(0, 0, -1),
        nextDir: new THREE.Vector3(0, 0, -1),
        bounds: 25
    };

    function init() {
        const container = document.getElementById('game-view');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf1f5f9);

        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(18, 15, 18);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // 環境設定
        scene.add(new THREE.AmbientLight(0xffffff, 0.9));
        const sun = new THREE.DirectionalLight(0xffffff, 0.5);
        sun.position.set(10, 20, 10);
        sun.castShadow = true;
        scene.add(sun);
        scene.add(new THREE.GridHelper(50, 20, 0xcbd5e1, 0xe2e8f0));

        // 建立鞋眼孔
        const ringGeo = new THREE.TorusGeometry(0.8, 0.2, 16, 60);
        const goldMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8, roughness: 0.2 });
        eyelet = new THREE.Mesh(ringGeo, goldMat);
        eyelet.rotation.x = Math.PI/2;
        scene.add(eyelet);

        // 建立織帶節點 (一次建立 50 節，模擬 Google AI Studio 的長度)
        const loader = new THREE.TextureLoader();
        const tex = loader.load('https://material.paiho.com/upload/BRD2147-J01F2.jpg');
        const partGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.6, 12);
        const partMat = new THREE.MeshStandardMaterial({ map: tex, color: 0xffffff });

        for(let i=0; i<60; i++) {
            const mesh = new THREE.Mesh(partGeo, partMat);
            mesh.scale.set(1.2, 1, 0.3); // 扁平化處理
            mesh.castShadow = true;
            scene.add(mesh);
            ropeParts.push(mesh);
        }

        resetGame();
        window.addEventListener('resize', onResize);
        animate();
    }

    function resetGame() {
        state.score = 0;
        state.status = 'PLAY';
        state.threadMode = 'down';
        state.headPos.set(0, 0.6, 0);
        state.currentDir.set(0, 0, -1);
        state.nextDir.set(0, 0, -1);
        document.getElementById('score-val').innerText = '0';
        document.getElementById('over-mask').classList.add('hidden');
        spawnEyelet();
    }

    function spawnEyelet() {
        const range = state.bounds - 5;
        eyelet.position.set((Math.random()-0.5)*range, 0.1, (Math.random()-0.5)*range);
    }

    function handleInput(x, z) {
        const newDir = new THREE.Vector3(x, 0, -z);
        if (newDir.dot(state.currentDir) === 0) state.nextDir.copy(newDir);
    }

    function onResize() {
        const container = document.getElementById('game-view');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (state.status !== 'PLAY') return;

        // 邏輯：平滑轉向與移動
        state.currentDir.lerp(state.nextDir, 0.18);
        state.headPos.addScaledVector(state.currentDir, 0.18);

        // 邏輯：接近鞋眼時的交替穿孔位移
        const dist = state.headPos.distanceTo(eyelet.position);
        if (dist < 2.5) {
            const curve = Math.sin((2.5 - dist) * (Math.PI / 2.5)) * 3.5;
            state.headPos.y = (state.threadMode === 'down') ? 0.6 - curve : -2.0 + curve;
            
            if (dist < 0.3) {
                state.score++;
                document.getElementById('score-val').innerText = state.score;
                state.threadMode = (state.threadMode === 'down') ? 'up' : 'down';
                spawnEyelet();
            }
        } else {
            state.headPos.y = (state.threadMode === 'down') ? 0.6 : -2.0;
        }

        // 視覺：繩索節點跟隨
        for(let i = ropeParts.length - 1; i >= 0; i--) {
            const p = ropeParts[i];
            if (i === 0) {
                p.position.copy(state.headPos);
                p.lookAt(p.position.clone().add(state.currentDir));
                p.rotateX(Math.PI/2);
            } else {
                p.position.lerp(ropeParts[i-1].position, 0.25);
                p.lookAt(ropeParts[i-1].position);
                p.rotateX(Math.PI/2);
            }
        }

        // 邊界檢查
        if (Math.abs(state.headPos.x) > state.bounds || Math.abs(state.headPos.z) > state.bounds) {
            state.status = 'OVER';
            document.getElementById('over-mask').classList.remove('hidden');
        }

        renderer.render(scene, camera);
    }

    window.onload = init;
</script>
</body>
</html>
