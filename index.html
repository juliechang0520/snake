<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PAIHO Elite - Alternating Threading</title>
    <style>
        :root { --paiho-red: #e60012; }
        body { margin: 0; background: #000; overflow: hidden; display: flex; flex-direction: column; height: 100vh; font-family: sans-serif; }
        #header { height: 10%; background: #000; display: flex; align-items: center; justify-content: center; color: white; border-bottom: 3px solid var(--paiho-red); z-index: 10; }
        #game-container { flex: 1; position: relative; background: #151515; }
        #controls { height: 25%; background: #d1d9e6; display: grid; grid-template-columns: repeat(3, 1fr); align-items: center; justify-items: center; border-top: 5px solid #888; box-shadow: inset 0 10px 20px rgba(0,0,0,0.3); }
        .btn-socket { width: 70px; height: 70px; background: #bdc7d4; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: inset 4px 4px 8px #9ea7b5, inset -4px -4px 8px #ffffff; }
        .joy-btn { width: 55px; height: 55px; background: var(--paiho-red); border: none; border-radius: 50%; color: white; font-size: 24px; box-shadow: 0 5px 0 #900; transition: 0.1s; cursor: pointer; }
        .joy-btn:active { transform: translateY(4px); box-shadow: 0 1px 0 #900; }
        .up { grid-column: 2; } .left { grid-column: 1; grid-row: 2; } .down { grid-column: 2; grid-row: 2; } .right { grid-column: 3; grid-row: 2; }
        #ui { position: absolute; top: 15px; left: 20px; color: white; font-weight: 900; pointer-events: none; }
    </style>
</head>
<body>

<div id="header"><div style="letter-spacing:4px; font-weight:900;">PAIHO <span style="color:var(--paiho-red)">ELITE ROPE</span></div></div>
<div id="game-container"><div id="ui">SCORE: <span id="score-val">0</span> | MODE: <span id="mode-val" style="color:var(--paiho-red)">DOWN</span></div></div>
<div id="controls">
    <div class="btn-socket up"><button class="joy-btn" onclick="setDir(0,1)">▲</button></div>
    <div class="btn-socket left"><button class="joy-btn" onclick="setDir(-1,0)">◀</button></div>
    <div class="btn-socket down"><button class="joy-btn" onclick="setDir(0,-1)">▼</button></div>
    <div class="btn-socket right"><button class="joy-btn" onclick="setDir(1,0)">▶</button></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, snake = [], eyelet, ropeTexture;
    let dx = 0, dz = 1, score = 0, lastTick = 0;
    let threadMode = "down"; // 交替模式: down -> up -> down
    let isAnimating = false;
    const spacing = 2.1;

    function init() {
        const container = document.getElementById('game-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        const aspect = container.clientWidth / container.clientHeight;
        const d = 14;
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20); 
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const loader = new THREE.TextureLoader();
        ropeTexture = loader.load('https://material.paiho.com/upload/BRD2147-J01F2.jpg');
        ropeTexture.wrapS = ropeTexture.wrapT = THREE.RepeatWrapping;
        ropeTexture.repeat.set(1, 2);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const light = new THREE.DirectionalLight(0xffffff, 0.6);
        light.position.set(10, 25, 10);
        light.castShadow = true;
        scene.add(light);

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(40,40), new THREE.MeshStandardMaterial({color: 0x1a1a1a, roughness: 1}));
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);
        scene.add(new THREE.GridHelper(30, 15, 0x222222, 0x111111));

        for(let i=0; i<4; i++) addRopePart(0, i);

        const torusGeo = new THREE.TorusGeometry(0.8, 0.25, 16, 100);
        const torusMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.9, roughness: 0.1 });
        eyelet = new THREE.Mesh(torusGeo, torusMat);
        eyelet.rotation.x = Math.PI/2;
        eyelet.position.set(4, 0.1, -4);
        scene.add(eyelet);
    }

    function addRopePart(x, z) {
        const geo = new THREE.CylinderGeometry(0.65, 0.65, 2.1, 16);
        const mat = new THREE.MeshStandardMaterial({ map: ropeTexture });
        const part = new THREE.Mesh(geo, mat);
        part.rotation.z = Math.PI / 2;
        part.position.set(x * spacing, 0.65, z * spacing);
        part.castShadow = true;
        scene.add(part);
        snake.push(part);
    }

    function runThreadingAnimation() {
        isAnimating = true;
        const head = snake[0];
        const originalY = 0.65;
        let progress = 0;

        const animateLoop = () => {
            progress += 0.08;
            if (threadMode === "down") {
                // 由上往下：躍起後垂直向下
                if (progress < 0.5) head.position.y = originalY + Math.sin(progress * Math.PI) * 2;
                else head.position.y = originalY - Math.sin((progress-0.5) * Math.PI) * 1.5;
            } else {
                // 由下往上：先沉下去再竄出
                if (progress < 0.5) head.position.y = originalY - Math.sin(progress * Math.PI) * 1.5;
                else head.position.y = originalY + Math.sin((progress-0.5) * Math.PI) * 2;
            }

            if (progress >= 1) {
                head.position.y = originalY;
                isAnimating = false;
                // 切換下一次模式
                threadMode = threadMode === "down" ? "up" : "down";
                document.getElementById('mode-val').innerText = threadMode.toUpperCase();
                eyelet.position.set((Math.floor(Math.random()*10)-5)*spacing, 0.1, (Math.floor(Math.random()*10)-5)*spacing);
                return;
            }
            requestAnimationFrame(animateLoop);
        };
        animateLoop();
    }

    function update() {
        if (dx === 0 && dz === 0 || isAnimating) return;

        const headPos = snake[0].position.clone();
        headPos.x += dx * spacing;
        headPos.z -= dz * spacing;

        if (headPos.distanceTo(eyelet.position) < 1.5) {
            score++;
            document.getElementById('score-val').innerText = score;
            runThreadingAnimation();
            const newPart = snake[snake.length-1].clone();
            snake.push(newPart);
            scene.add(newPart);
        }

        for(let i = snake.length - 1; i > 0; i--) {
            snake[i].position.copy(snake[i-1].position);
            snake[i].rotation.copy(snake[i-1].rotation);
        }
        
        snake[0].position.copy(headPos);
        if(dx !== 0) snake[0].rotation.set(0, 0, Math.PI / 2);
        else if(dz !== 0) snake[0].rotation.set(Math.PI / 2, 0, 0);

        if(Math.abs(headPos.x) > 16 || Math.abs(headPos.z) > 16) location.reload();
    }

    function animate(t) {
        requestAnimationFrame(animate);
        if (t - lastTick > 220) {
            update();
            lastTick = t;
        }
        renderer.render(scene, camera);
    }

    function setDir(x, z) {
        if ((x !== 0 && dx === -x) || (z !== 0 && dz === -z)) return;
        dx = x; dz = z;
    }

    window.onload = () => { init(); animate(0); };
</script>
</body>
</html>
