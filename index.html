<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PAIHO 3D Snake - Lace Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f1f5f9;
            margin: 0;
            padding: 0;
            overflow: hidden;
            -webkit-user-select: none;
            touch-action: none;
        }
        #root { height: 100vh; display: flex; flex-direction: column; }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@19.0.0",
        "react-dom": "https://esm.sh/react-dom@19.0.0",
        "react-dom/client": "https://esm.sh/react-dom@19.0.0/client",
        "three": "https://esm.sh/three@0.160.0"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="module">
        import React, { useState, useRef, useCallback, useEffect, useImperativeHandle, forwardRef } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';

        // --- CONSTANTS ---
        const COLORS = {
            PAIHO_RED: '#D31A24', 
            PAIHO_DARK_RED: '#800D12',
            GOLD: '#D4AF37',
            DARK_BG: '#F1F5F9',   
            GROUND: '#FFFFFF',    
            GRID: '#CBD5E1',      
            HOLE_INNER: '#0F172A',
            UI_BG: '#FFFFFF', 
            BORDER: '#E2E8F0',
            METAL_GOLD: '#F59E0B', 
            CHROME: '#94A3B8',
        };

        const ROPE_TEXTURE_URL = 'https://material.paiho.com/upload/BRD2147-J01F2.jpg';

        const GAME_CONFIG = {
            GRID_SIZE: 2.0,        
            INITIAL_SEGMENTS: 80,  
            MAX_SEGMENTS: 1000,    
            SEGMENT_LENGTH: 0.1,  
            ROPE_RADIUS: 0.5,      
            ROPE_THICKNESS: 0.15,  
            MOVE_SPEED: 0.22,      
            AUTO_SPEED: 0.45,       
            THRESHOLD_DISTANCE: 1.0, 
            EYELET_RADIUS: 1.4,    
            BOUNDS: 24,            
            UPPER_Y: 0.6,          
            LOWER_Y: -2.5,         
            GROWTH_AMOUNT: 20,     
            AGLET_LENGTH: 2.5,     
        };

        const GameCanvas = forwardRef(({ onScoreChange, onGameOver }, ref) => {
            const containerRef = useRef(null);
            const rendererRef = useRef(null);
            const ropeMeshRef = useRef(null);
            const agletMeshRef = useRef(null); 
            const targetEyeletRef = useRef(null);
            const exitEyeletRef = useRef(null);
            const pathHistoryRef = useRef([]);
            const sceneRef = useRef(new THREE.Scene());
            
            const stateRef = useRef({
                status: 'PLAYER',
                targetPos: new THREE.Vector3(0, GAME_CONFIG.UPPER_Y, 0),
                currentDir: new THREE.Vector3(0, 0, -1),
                nextDir: null,
                score: 0,
                activeSegments: GAME_CONFIG.INITIAL_SEGMENTS,
                exitPos: new THREE.Vector3(),
                threadMode: 'down' // 'down' or 'up'
            });

            const create3DEyelet = (isTarget) => {
                const group = new THREE.Group();
                const metalMat = new THREE.MeshStandardMaterial({ 
                    color: isTarget ? COLORS.GOLD : COLORS.CHROME, 
                    metalness: 1.0, 
                    roughness: 0.1 
                });
                const torus = new THREE.Mesh(new THREE.TorusGeometry(GAME_CONFIG.EYELET_RADIUS - 0.1, 0.15, 16, 32), metalMat);
                torus.rotation.x = Math.PI / 2;
                torus.position.y = 0.2;
                const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(GAME_CONFIG.EYELET_RADIUS, GAME_CONFIG.EYELET_RADIUS, 0.4, 32), metalMat);
                cylinder.position.y = 0.1;
                const hole = new THREE.Mesh(new THREE.CircleGeometry(GAME_CONFIG.EYELET_RADIUS - 0.2, 32), new THREE.MeshBasicMaterial({ color: COLORS.HOLE_INNER }));
                hole.rotation.x = -Math.PI / 2;
                hole.position.y = 0.05;
                group.add(torus, cylinder, hole);
                return group;
            };

            const spawnTarget = () => {
                const grid = GAME_CONFIG.GRID_SIZE;
                const range = GAME_CONFIG.BOUNDS - 4;
                const x = Math.round((Math.random() * range * 2 - range) / grid) * grid;
                const z = Math.round((Math.random() * range * 2 - range) / grid) * grid;
                targetEyeletRef.current.position.set(x, 0, z);
                targetEyeletRef.current.visible = true;
            };

            const resetGame = () => {
                const s = stateRef.current;
                s.status = 'PLAYER';
                s.score = 0;
                s.threadMode = 'down';
                s.activeSegments = GAME_CONFIG.INITIAL_SEGMENTS;
                s.targetPos.set(0, GAME_CONFIG.UPPER_Y, 0);
                s.currentDir.set(0, 0, -1);
                pathHistoryRef.current = [];
                for(let i=0; i<30; i++) pathHistoryRef.current.push(new THREE.Vector3(0, GAME_CONFIG.UPPER_Y, i*0.1));
                spawnTarget();
                onScoreChange(0);
            };

            useImperativeHandle(ref, () => ({
                setDirection: (x, z) => {
                    const s = stateRef.current;
                    const newDir = new THREE.Vector3(x, 0, -z).normalize();
                    if (newDir.dot(s.currentDir) > -0.8) s.nextDir = newDir;
                },
                reset: resetGame
            }));

            useEffect(() => {
                const container = containerRef.current;
                const scene = sceneRef.current;
                scene.background = new THREE.Color(COLORS.DARK_BG);

                const aspect = container.clientWidth / container.clientHeight;
                const d = 15;
                const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
                camera.position.set(20, 20, 20); 
                camera.lookAt(0, 0, 0);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.shadowMap.enabled = true;
                container.appendChild(renderer.domElement);

                scene.add(new THREE.AmbientLight(0xffffff, 0.8));
                const sun = new THREE.DirectionalLight(0xffffff, 0.6);
                sun.position.set(10, 20, 10);
                scene.add(sun);

                const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: COLORS.GROUND }));
                ground.rotation.x = -Math.PI / 2;
                scene.add(ground);
                scene.add(new THREE.GridHelper(100, 50, COLORS.GRID, COLORS.GRID));

                const loader = new THREE.TextureLoader();
                const ropeTex = loader.load(ROPE_TEXTURE_URL);
                ropeTex.wrapS = ropeTex.wrapT = THREE.RepeatWrapping;

                const ropeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, map: ropeTex });
                ropeMeshRef.current = new THREE.Mesh(new THREE.BufferGeometry(), ropeMat);
                scene.add(ropeMeshRef.current);

                targetEyeletRef.current = create3DEyelet(true);
                scene.add(targetEyeletRef.current);

                resetGame();

                const update = () => {
                    const s = stateRef.current;
                    if (s.status === 'OVER') return;

                    if (s.nextDir) { s.currentDir.lerp(s.nextDir, 0.2); s.nextDir = null; }
                    
                    const head = s.targetPos;
                    head.add(s.currentDir.clone().multiplyScalar(GAME_CONFIG.MOVE_SPEED));

                    // 穿孔動態邏輯：由上往下 / 由下往上交替
                    const dist = head.distanceTo(targetEyeletRef.current.position);
                    if (dist < 2.0) {
                        const effect = Math.sin((2.0 - dist) * (Math.PI / 2.0)) * 3.0;
                        head.y = (s.threadMode === 'down') ? 0.6 - effect : -2.5 + effect;
                        
                        if (dist < 0.3) {
                            s.score++;
                            onScoreChange(s.score);
                            s.threadMode = s.threadMode === 'down' ? 'up' : 'down';
                            spawnTarget();
                        }
                    } else {
                        head.y = (s.threadMode === 'down') ? 0.6 : -2.5;
                    }

                    pathHistoryRef.current.unshift(head.clone());
                    if (pathHistoryRef.current.length > GAME_CONFIG.MAX_SEGMENTS) pathHistoryRef.current.pop();

                    // 更新 Tube 幾何體
                    if (pathHistoryRef.current.length > 2) {
                        const curve = new THREE.CatmullRomCurve3(pathHistoryRef.current);
                        const newGeo = new THREE.TubeGeometry(curve, pathHistoryRef.current.length, GAME_CONFIG.ROPE_RADIUS, 8, false);
                        
                        // 織帶扁平化處理
                        const pos = newGeo.attributes.position;
                        for(let i=0; i<pos.count; i++) pos.setY(i, pos.getY(i) * 0.3);
                        
                        if (ropeMeshRef.current.geometry) ropeMeshRef.current.geometry.dispose();
                        ropeMeshRef.current.geometry = newGeo;
                    }

                    if (Math.abs(head.x) > 30 || Math.abs(head.z) > 30) {
                        s.status = 'OVER';
                        onGameOver();
                    }
                };

                const animate = () => {
                    update();
                    renderer.render(scene, camera);
                    rendererRef.current = requestAnimationFrame(animate);
                };
                animate();

                return () => {
                    cancelAnimationFrame(rendererRef.current);
                    renderer.dispose();
                };
            }, []);

            return <div ref={containerRef} className="w-full h-full" />;
        });

        const Controls = ({ onDirection }) => (
            <div className="h-[200px] bg-[#d1d9e6] grid grid-cols-3 grid-rows-2 items-center justify-items-center p-4">
                <button onPointerDown={() => onDirection(0, 1)} className="w-14 h-14 bg-[#D31A24] rounded-full text-white shadow-[0_4px_0_#900] col-start-2">▲</button>
                <button onPointerDown={() => onDirection(-1, 0)} className="w-14 h-14 bg-[#D31A24] rounded-full text-white shadow-[0_4px_0_#900] col-start-1 row-start-2">◀</button>
                <button onPointerDown={() => onDirection(0, -1)} className="w-14 h-14 bg-[#D31A24] rounded-full text-white shadow-[0_4px_0_#900] col-start-2 row-start-2">▼</button>
                <button onPointerDown={() => onDirection(1, 0)} className="w-14 h-14 bg-[#D31A24] rounded-full text-white shadow-[0_4px_0_#900] col-start-3 row-start-2">▶</button>
            </div>
        );

        const App = () => {
            const [score, setScore] = useState(0);
            const [isGameOver, setIsGameOver] = useState(false);
            const gameRef = useRef();

            return (
                <div className="flex flex-col h-screen">
                    <header className="h-14 flex items-center justify-between px-6 bg-white border-b">
                        <span className="font-black text-xl">PAIHO <span className="text-red-600">SNAKE</span></span>
                        <div className="font-bold">SCORE: {score}</div>
                    </header>
                    <div className="flex-1 relative">
                        <GameCanvas ref={gameRef} onScoreChange={setScore} onGameOver={() => setIsGameOver(true)} />
                        {isGameOver && (
                            <div className="absolute inset-0 bg-black/60 flex items-center justify-center z-50">
                                <div className="bg-white p-8 rounded-3xl text-center">
                                    <h2 className="text-2xl font-bold mb-4">Game Over</h2>
                                    <button onClick={() => { setIsGameOver(false); gameRef.current.reset(); }} className="px-6 py-2 bg-red-600 text-white rounded-full">Restart</button>
                                </div>
                            </div>
                        )}
                    </div>
                    <Controls onDirection={(x, z) => gameRef.current.setDirection(x, z)} />
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
