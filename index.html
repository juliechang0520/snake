<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PAIHO 3D Interactive Rope</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root { --paiho-red: #D31A24; }
        * { touch-action: none; -webkit-user-select: none; box-sizing: border-box; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #f1f5f9; overflow: hidden; position: fixed; }
        #game-container { cursor: move; }
    </style>
</head>
<body class="flex flex-col h-screen">

<header class="h-14 flex items-center justify-between px-6 bg-white border-b border-slate-200 z-30 shadow-sm">
    <span class="font-black text-slate-900 tracking-tighter text-xl">PAIHO <span class="text-red-600">SNAKE</span></span>
    <div class="bg-slate-50 px-4 py-1 rounded-full border border-slate-200 font-bold">
        SCORE: <span id="score-val" class="text-red-600">0</span>
    </div>
</header>

<div id="game-container" class="flex-1 relative bg-slate-100">
    <div id="ui-hint" class="absolute top-4 left-4 bg-black/50 text-white text-xs px-3 py-1 rounded-full pointer-events-none">
        拖曳畫面可旋轉視角 360°
    </div>
</div>

<div id="controls" class="h-44 bg-[#d1d9e6] grid grid-cols-3 grid-rows-2 items-center justify-items-center p-4">
    <button class="w-14 h-14 bg-red-600 rounded-full text-white shadow-[0_4px_0_#900] active:translate-y-1 col-start-2" onclick="setDir(0,1)">▲</button>
    <button class="w-14 h-14 bg-red-600 rounded-full text-white shadow-[0_4px_0_#900] active:translate-y-1 col-start-1 row-start-2" onclick="setDir(-1,0)">◀</button>
    <button class="w-14 h-14 bg-red-600 rounded-full text-white shadow-[0_4px_0_#900] active:translate-y-1 col-start-2 row-start-2" onclick="setDir(0,-1)">▼</button>
    <button class="w-14 h-14 bg-red-600 rounded-full text-white shadow-[0_4px_0_#900] active:translate-y-1 col-start-3 row-start-2" onclick="setDir(1,0)">▶</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, ropeParts = [], eyelet;
    let targetPos = new THREE.Vector3(0, 0.4, 0);
    let currentDir = new THREE.Vector3(0, 0, -1);
    let nextDir = new THREE.Vector3(0, 0, -1);
    let score = 0, threadStep = 0, rotationAngle = Math.PI / 4;
    let isDragging = false, lastMouseX = 0;

    function init() {
        const container = document.getElementById('game-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf1f5f9);

        const aspect = container.clientWidth / container.clientHeight;
        const d = 12;
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
        updateCamera();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const loader = new THREE.TextureLoader();
        const ropeTex = loader.load('https://material.paiho.com/upload/BRD2147-J01F2.jpg');
        ropeTex.wrapS = ropeTex.wrapT = THREE.RepeatWrapping;

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const light = new THREE.DirectionalLight(0xffffff, 0.6);
        light.position.set(10, 20, 10);
        light.castShadow = true;
        scene.add(light);

        // 地板 (半透明)
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 60),
            new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        scene.add(new THREE.GridHelper(40, 20, 0xCBD5E1, 0xe2e8f0));

        // 建立繩索節點 (使用圓柱體模擬繩索立體感)
        for (let i = 0; i < 30; i++) {
            const part = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.4, 0.6, 12),
                new THREE.MeshStandardMaterial({ color: 0xffffff, map: ropeTex })
            );
            part.castShadow = true;
            scene.add(part);
            ropeParts.push(part);
        }

        // 鞋眼孔
        eyelet = new THREE.Group();
        const ring = new THREE.Mesh(new THREE.TorusGeometry(0.8, 0.2, 16, 100), new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8 }));
        ring.rotation.x = Math.PI/2;
        eyelet.add(ring);
        eyelet.position.set(0, 0.1, -6);
        scene.add(eyelet);

        // 視角控制
        container.addEventListener('pointerdown', e => { isDragging = true; lastMouseX = e.clientX; });
        window.addEventListener('pointermove', e => {
            if (isDragging) {
                rotationAngle -= (e.clientX - lastMouseX) * 0.01;
                updateCamera();
                lastMouseX = e.clientX;
            }
        });
        window.addEventListener('pointerup', () => isDragging = false);
    }

    function updateCamera() {
        camera.position.x = Math.cos(rotationAngle) * 20;
        camera.position.z = Math.sin(rotationAngle) * 20;
        camera.position.y = 12;
        camera.lookAt(0, 0, 0);
    }

    function setDir(x, z) {
        let n = new THREE.Vector3(x, 0, -z);
        if (n.dot(currentDir) === 0) nextDir.copy(n);
    }

    function animate() {
        requestAnimationFrame(animate);

        currentDir.lerp(nextDir, 0.15);
        targetPos.addScaledVector(currentDir, 0.15);

        let dist = targetPos.distanceTo(eyelet.position);
        let yBase = 0.4;

        // 穿孔動態：交替上下
        if (dist < 2.5) {
            let mode = (threadStep % 2 === 0) ? -1 : 1; // -1 是往下, 1 是往上
            yBase = 0.4 + Math.sin((2.5 - dist) * (Math.PI / 2.5)) * 3.5 * mode;
            
            if (dist < 0.3) {
                threadStep++;
                score++;
                document.getElementById('score-val').innerText = score;
                eyelet.position.set((Math.random()-0.5)*16, 0.1, (Math.random()-0.5)*16);
            }
        }

        // 繩索跟隨
        for (let i = ropeParts.length - 1; i >= 0; i--) {
            if (i === 0) {
                ropeParts[i].position.set(targetPos.x, yBase, targetPos.z);
                ropeParts[i].lookAt(ropeParts[i].position.clone().add(currentDir));
                ropeParts[i].rotateX(Math.PI/2);
            } else {
                ropeParts[i].position.lerp(ropeParts[i-1].position, 0.3);
                ropeParts[i].lookAt(ropeParts[i-1].position);
                ropeParts[i].rotateX(Math.PI/2);
            }
        }

        if (targetPos.length() > 30) targetPos.set(0, 0.4, 0);
        renderer.render(scene, camera);
    }

    window.onload = () => { init(); animate(); };
</script>
</body>
</html>
