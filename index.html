<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PAIHO 3D Smooth Rope</title>
    <style>
        :root { --paiho-red: #e60012; }
        * { touch-action: none; -webkit-user-select: none; }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: #000; overflow: hidden; position: fixed;
            display: flex; flex-direction: column; font-family: sans-serif;
        }
        
        #header { height: 60px; background: #000; display: flex; align-items: center; justify-content: center; color: white; border-bottom: 2px solid var(--paiho-red); }
        #game-container { flex: 1; position: relative; width: 100%; overflow: hidden; }
        
        /* 手機按鈕區優化 */
        #controls { 
            height: 200px; background: #d1d9e6; 
            display: grid; grid-template-columns: repeat(3, 1fr); 
            align-items: center; justify-items: center;
            padding-bottom: env(safe-area-inset-bottom);
        }
        .btn-socket { width: 65px; height: 65px; background: #bdc7d4; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: inset 4px 4px 8px #9ea7b5, inset -4px -4px 8px #ffffff; }
        .joy-btn { width: 55px; height: 55px; background: var(--paiho-red); border: none; border-radius: 50%; color: white; font-size: 24px; box-shadow: 0 4px 0 #900; }
        .joy-btn:active { transform: translateY(2px); box-shadow: 0 1px 0 #900; }
        .up { grid-column: 2; } .left { grid-column: 1; grid-row: 2; } .down { grid-column: 2; grid-row: 2; } .right { grid-column: 3; grid-row: 2; }
        #ui { position: absolute; top: 10px; left: 15px; color: white; font-size: 14px; pointer-events: none; }
    </style>
</head>
<body>

<div id="header"><b style="letter-spacing:2px;">PAIHO 3D SIDE-VIEW</b></div>
<div id="game-container"><div id="ui">SCORE: <span id="score-val">0</span></div></div>
<div id="controls">
    <div class="btn-socket up"><button class="joy-btn" onclick="setDir(0,1)">▲</button></div>
    <div class="btn-socket left"><button class="joy-btn" onclick="setDir(-1,0)">◀</button></div>
    <div class="btn-socket down"><button class="joy-btn" onclick="setDir(0,-1)">▼</button></div>
    <div class="btn-socket right"><button class="joy-btn" onclick="setDir(1,0)">▶</button></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, ropeParts = [], eyelet;
    let targetPos = new THREE.Vector3(0, 0.4, 0);
    let currentDir = new THREE.Vector3(0, 0, -1);
    let nextDir = new THREE.Vector3(0, 0, -1);
    let score = 0, threadStep = 0;
    const moveSpeed = 0.15; // 滑順移動速度

    function init() {
        const container = document.getElementById('game-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        // 水平側面正交相機
        const aspect = container.clientWidth / container.clientHeight;
        const d = 10;
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(15, 8, 15); // 側低角度
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // 白色繩索織帶貼圖
        const loader = new THREE.TextureLoader();
        const ropeTex = loader.load('https://material.paiho.com/upload/BRD2147-J01F2.jpg');
        ropeTex.wrapS = ropeTex.wrapT = THREE.RepeatWrapping;
        ropeTex.repeat.set(1, 1);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const light = new THREE.DirectionalLight(0xffffff, 0.5);
        light.position.set(10, 20, 10);
        light.castShadow = true;
        scene.add(light);

        // 透明地板（為了看穿孔下方）
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(50, 50),
            new THREE.MeshStandardMaterial({ color: 0x222222, transparent: true, opacity: 0.7 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        scene.add(new THREE.GridHelper(30, 20, 0x333333, 0x222222));

        // 初始繩索
        for (let i = 0; i < 15; i++) {
            const geo = new THREE.CylinderGeometry(0.4, 0.4, 0.8, 12);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, map: ropeTex });
            const p = new THREE.Mesh(geo, mat);
            p.castShadow = true;
            p.position.set(0, 0.4, i * 0.7);
            scene.add(p);
            ropeParts.push(p);
        }

        // 鞋眼孔
        eyelet = new THREE.Mesh(
            new THREE.TorusGeometry(0.8, 0.2, 16, 100),
            new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8, roughness: 0.2 })
        );
        eyelet.rotation.x = Math.PI / 2;
        eyelet.position.set(0, 0.05, -5);
        scene.add(eyelet);
    }

    function setDir(x, z) {
        let n = new THREE.Vector3(x, 0, -z);
        if (n.dot(currentDir) === 0) nextDir.copy(n);
    }

    function animate() {
        requestAnimationFrame(animate);

        // 1. 滑順移動邏輯
        currentDir.lerp(nextDir, 0.1); 
        targetPos.addScaledVector(currentDir, moveSpeed);

        // 2. 穿孔判定與動態
        let dist = targetPos.distanceTo(eyelet.position);
        let yOffset = 0.4;
        
        // 穿孔波動
        if (dist < 3) {
            let cycle = (threadStep % 2 === 0) ? 1 : -1;
            yOffset = 0.4 + Math.sin((3 - dist) * 1.2) * 2.5 * cycle;
            
            if (dist < 0.3) {
                threadStep++;
                score++;
                document.getElementById('score-val').innerText = score;
                eyelet.position.set((Math.random()-0.5)*15, 0.05, (Math.random()-0.5)*15);
            }
        }

        // 3. 更新繩索每一節的位置（跟隨與旋轉）
        for (let i = ropeParts.length - 1; i >= 0; i--) {
            if (i === 0) {
                ropeParts[i].position.set(targetPos.x, yOffset, targetPos.z);
                // 指向移動方向
                let lookTarget = ropeParts[i].position.clone().add(currentDir);
                ropeParts[i].lookAt(lookTarget);
                ropeParts[i].rotateX(Math.PI/2);
            } else {
                // 每一節滑順跟隨前一節
                ropeParts[i].position.lerp(ropeParts[i - 1].position, 0.4);
                ropeParts[i].lookAt(ropeParts[i - 1].position);
                ropeParts[i].rotateX(Math.PI/2);
            }
        }

        // 邊界重置
        if (Math.abs(targetPos.x) > 20 || Math.abs(targetPos.z) > 20) {
            targetPos.set(0, 0.4, 0);
        }

        renderer.render(scene, camera);
    }

    window.onload = () => { init(); animate(); };
    window.addEventListener('resize', () => {
        const container = document.getElementById('game-container');
        const aspect = container.clientWidth / container.clientHeight;
        const d = 10;
        camera.left = -d * aspect; camera.right = d * aspect;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });
</script>
</body>
</html>
