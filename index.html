<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PAIHO 3D Interactive Rope</title>
    <style>
        :root { --paiho-red: #e60012; }
        * { touch-action: none; -webkit-user-select: none; box-sizing: border-box; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; position: fixed; display: flex; flex-direction: column; }
        #header { height: 50px; background: #000; display: flex; align-items: center; justify-content: center; color: white; border-bottom: 2px solid var(--paiho-red); font-weight: 900; }
        #game-container { flex: 1; position: relative; width: 100%; cursor: move; }
        #controls { height: 180px; background: #d1d9e6; display: grid; grid-template-columns: repeat(3, 1fr); align-items: center; justify-items: center; padding-bottom: env(safe-area-inset-bottom); }
        .btn-socket { width: 60px; height: 60px; background: #bdc7d4; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: inset 4px 4px 8px #9ea7b5, inset -4px -4px 8px #ffffff; }
        .joy-btn { width: 50px; height: 50px; background: var(--paiho-red); border: none; border-radius: 50%; color: white; font-size: 20px; box-shadow: 0 4px 0 #900; }
        .joy-btn:active { transform: translateY(2px); box-shadow: 0 1px 0 #900; }
        .up { grid-column: 2; } .left { grid-column: 1; grid-row: 2; } .down { grid-column: 2; grid-row: 2; } .right { grid-column: 3; grid-row: 2; }
        #ui { position: absolute; top: 10px; left: 15px; color: white; font-size: 12px; pointer-events: none; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 10px; }
    </style>
</head>
<body>

<div id="header">PAIHO 3D ROTATABLE</div>
<div id="game-container">
    <div id="ui">SCORE: <span id="score-val">0</span> | <small>拖曳畫面旋轉視角</small></div>
</div>
<div id="controls">
    <div class="btn-socket up"><button class="joy-btn" onclick="setDir(0,1)">▲</button></div>
    <div class="btn-socket left"><button class="joy-btn" onclick="setDir(-1,0)">◀</button></div>
    <div class="btn-socket down"><button class="joy-btn" onclick="setDir(0,-1)">▼</button></div>
    <div class="btn-socket right"><button class="joy-btn" onclick="setDir(1,0)">▶</button></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, ropeParts = [], eyelet;
    let targetPos = new THREE.Vector3(0, 0.4, 0);
    let currentDir = new THREE.Vector3(0, 0, -1);
    let nextDir = new THREE.Vector3(0, 0, -1);
    let score = 0, threadStep = 0, isThreading = false;
    let rotationAngle = Math.PI / 4;
    let isDragging = false, lastMouseX = 0;

    function init() {
        const container = document.getElementById('game-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        const aspect = container.clientWidth / container.clientHeight;
        const d = 12;
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
        updateCameraPosition();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const loader = new THREE.TextureLoader();
        const ropeTex = loader.load('https://material.paiho.com/upload/BRD2147-J01F2.jpg');
        ropeTex.wrapS = ropeTex.wrapT = THREE.RepeatWrapping;

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const light = new THREE.DirectionalLight(0xffffff, 0.6);
        light.position.set(10, 20, 10);
        light.castShadow = true;
        scene.add(light);

        // 地板
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 60),
            new THREE.MeshStandardMaterial({ color: 0x333333, transparent: true, opacity: 0.6 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        scene.add(new THREE.GridHelper(30, 20, 0x444444, 0x222222));

        // 初始繩索 (增長節數讓動態更穩)
        for (let i = 0; i < 25; i++) {
            const part = new THREE.Mesh(
                new THREE.CylinderGeometry(0.35, 0.35, 0.6, 12),
                new THREE.MeshStandardMaterial({ color: 0xffffff, map: ropeTex })
            );
            part.position.set(0, 0.4, i * 0.5);
            part.castShadow = true;
            scene.add(part);
            ropeParts.push(part);
        }

        // 鞋眼孔
        eyelet = new THREE.Mesh(
            new THREE.TorusGeometry(0.8, 0.2, 16, 100),
            new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8, roughness: 0.2 })
        );
        eyelet.rotation.x = Math.PI / 2;
        eyelet.position.set(0, 0.05, -5);
        scene.add(eyelet);

        // 滑鼠/觸控互動
        container.addEventListener('pointerdown', (e) => { isDragging = true; lastMouseX = e.clientX; });
        window.addEventListener('pointermove', (e) => {
            if (isDragging) {
                let delta = e.clientX - lastMouseX;
                rotationAngle -= delta * 0.01;
                updateCameraPosition();
                lastMouseX = e.clientX;
            }
        });
        window.addEventListener('pointerup', () => isDragging = false);
    }

    function updateCameraPosition() {
        const radius = 20;
        camera.position.x = Math.cos(rotationAngle) * radius;
        camera.position.z = Math.sin(rotationAngle) * radius;
        camera.position.y = 12;
        camera.lookAt(0, 0, 0);
    }

    function setDir(x, z) {
        let n = new THREE.Vector3(x, 0, -z);
        if (n.length() > 0 && n.dot(currentDir) === 0) nextDir.copy(n);
    }

    function animate() {
        requestAnimationFrame(animate);

        // 平滑轉向
        currentDir.lerp(nextDir, 0.15);
        targetPos.addScaledVector(currentDir, 0.12);

        let dist = targetPos.distanceTo(eyelet.position);
        let yBase = 0.
