<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>精密穿梭：Lace 3D 邏輯修正版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background-color: #020617; overflow: hidden; font-family: sans-serif; }
        #ui { position: absolute; top: 30px; width: 100%; text-align: center; pointer-events: none; z-index: 10; color: white; }
        .ui-container {
            display: inline-block; padding: 12px 24px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
        }
        .mode-tag { display: inline-block; padding: 4px 12px; border-radius: 99px; background: #ef4444; font-weight: 800; font-size: 0.7rem; text-transform: uppercase; margin-bottom: 5px; }
        .score-text { font-size: 2.5rem; font-weight: 900; line-height: 1; margin: 0; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="ui-container">
            <div id="statusTag" class="mode-tag">Manual Mode</div>
            <div class="score-text" id="score">0</div>
        </div>
    </div>

    <script>
        const scene = new THREE.Scene();
        const d = 5; 
        const aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(0, 50, 0); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(5, 15, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- 核心比例參數 ---
        const gridSize = 0.5; 
        const laceWidth = gridSize * 0.8; 
        const eyeletR = laceWidth / 2; 
        const offset = gridSize / 2; 

        // --- 背景網格 ---
        const planeSize = 100;
        const textureCanvas = document.createElement('canvas');
        textureCanvas.width = 128; textureCanvas.height = 128;
        const tCtx = textureCanvas.getContext('2d');
        tCtx.fillStyle = '#1e293b'; tCtx.fillRect(0, 0, 128, 128);
        tCtx.strokeStyle = 'rgba(255,255,255,0.1)'; tCtx.lineWidth = 2;
        tCtx.strokeRect(0, 0, 128, 128);
        const canvasTexture = new THREE.CanvasTexture(textureCanvas);
        canvasTexture.wrapS = canvasTexture.wrapT = THREE.RepeatWrapping;
        canvasTexture.repeat.set(planeSize / gridSize, planeSize / gridSize);
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(planeSize, planeSize), new THREE.MeshStandardMaterial({ map: canvasTexture }));
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);

        // --- 材質定義 ---
        const laceMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.5 });
        const eyeletMat = new THREE.MeshStandardMaterial({ color: 0xe2e8f0, metalness: 1.0, roughness: 0.15 });
        const holeInnerMat = new THREE.MeshBasicMaterial({ color: 0x0f172a }); // 深藍色孔內

        let score = 0;
        let isAutoMode = false;
        let snake = [{ x: 0, y: 0 }];
        let direction = { x: 1, y: 0 };
        let startHolePos = null; // 進入點
        let targetHolePos = { x: gridSize * 4, y: gridSize * 2 }; // 出現點
        
        let eyeletGroups = [];
        let laceMeshes = [];

        function createEyelet(x, y) {
            const group = new THREE.Group();
            const torus = new THREE.Mesh(new THREE.TorusGeometry(eyeletR, 0.045, 16, 64), eyeletMat);
            torus.rotation.x = Math.PI / 2; torus.position.y = 0.12; torus.castShadow = true;
            group.add(torus);

            const hole = new THREE.Mesh(new THREE.CircleGeometry(eyeletR, 32), holeInnerMat);
            hole.rotation.x = -Math.PI / 2; hole.position.y = 0.03;
            group.add(hole);

            group.position.set(x + offset, 0, y + offset);
            scene.add(group);
            eyeletGroups.push(group);
        }

        function updateEyelets() {
            eyeletGroups.forEach(g => scene.remove(g));
            eyeletGroups = [];
            // 如果在自動模式，起點與終點都有孔
            if (isAutoMode && startHolePos) createEyelet(startHolePos.x, startHolePos.y);
            createEyelet(targetHolePos.x, targetHolePos.y);
        }

        updateEyelets();

        function update() {
            let head = { ...snake[0] };
            if (isAutoMode) {
                // 自動移動邏輯
                if (Math.abs(head.x - targetHolePos.x) > 0.001) head.x += (head.x < targetHolePos.x ? gridSize : -gridSize);
                else if (Math.abs(head.y - targetHolePos.y) > 0.001) head.y += (head.y < targetHolePos.y ? gridSize : -gridSize);

                // 到達目標孔洞（出現點）
                if (Math.abs(head.x - targetHolePos.x) < 0.001 && Math.abs(head.y - targetHolePos.y) < 0.001) {
                    isAutoMode = false;
                    startHolePos = null;
                    document.getElementById('statusTag').innerText = "Manual Mode";
                    document.getElementById('statusTag').style.background = "#ef4444";
                    
                    // 重新產生下一個目標孔洞
                    targetHolePos = { x: Math.round(Math.random()*10-5)*gridSize, y: Math.round(Math.random()*10-5)*gridSize };
                    updateEyelets();
                }
            } else {
                head.x += direction.x * gridSize; head.y += direction.y * gridSize;
                if (Math.abs(head.x) > 10 || Math.abs(head.y) > 10) location.reload();

                // 碰到目標孔洞（開始穿入）
                if (Math.abs(head.x - targetHolePos.x) < 0.001 && Math.abs(head.y - targetHolePos.y) < 0.001) {
                    score++; document.getElementById('score').innerText = score;
                    isAutoMode = true;
                    startHolePos = { ...targetHolePos }; // 紀錄目前的穿入點
                    document.getElementById('statusTag').innerText = "Auto Sliding";
                    document.getElementById('statusTag').style.background = "#3b82f6";
                    updateEyelets(); // 此時會畫出進入點與出現點的孔
                }
            }
            snake.unshift(head);
            if (snake.length > 10) snake.pop();
            renderLace();
        }

        function renderLace() {
            laceMeshes.forEach(m => scene.remove(m));
            laceMeshes = [];
            
            snake.forEach((pos, i) => {
                // 自動模式中，身體隱藏，只處理頭部穿梭視覺
                if (isAutoMode && i > 0) return;

                const geo = new THREE.BoxGeometry(laceWidth, 0.08, gridSize); 
                const mesh = new THREE.Mesh(geo, laceMat);
                
                let yPos = 0.12;
                let scale = 1.0;
                let opacity = 1.0;

                // 穿梭動態修正
                if (isAutoMode && i === 0) {
                    // 如果頭部剛好在起點（進入點），模擬消失
                    if (Math.abs(pos.x - startHolePos.x) < 0.01 && Math.abs(pos.y - startHolePos.y) < 0.01) {
                        yPos = 0.05; scale = 0.7; // 縮小沉入
                    } 
                    // 如果頭部剛好在終點（出現點），模擬浮現
                    else if (Math.abs(pos.x - targetHolePos.x) < 0.01 && Math.abs(pos.y - targetHolePos.y) < 0.01) {
                        yPos = 0.08; scale = 0.9; // 浮現
                    } else {
                        // 在地底移動時完全不可見
                        return; 
                    }
                }

                if (i < snake.length - 1) {
                    const next = snake[i+1];
                    if (Math.abs(pos.x - next.x) > 0.01) mesh.rotation.y = Math.PI / 2;
                } else if (direction.x !== 0) {
                    mesh.rotation.y = Math.PI / 2;
                }

                mesh.scale.set(scale, 1, 1);
                mesh.position.set(pos.x + offset, yPos, pos.y + offset);
                mesh.castShadow = true;
                scene.add(mesh);
                laceMeshes.push(mesh);
            });
        }

        window.addEventListener('keydown', e => {
            if (isAutoMode) return;
            if (e.keyCode === 37 && direction.x === 0) direction = { x: -1, y: 0 };
            if (e.keyCode === 38 && direction.y === 0) direction = { x: 0, y: -1 };
            if (e.keyCode === 39 && direction.x === 0) direction = { x: 1, y: 0 };
            if (e.keyCode === 40 && direction.y === 0) direction = { x: 0, y: 1 };
        });

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        setInterval(update, 200); 
        animate();
    </script>
</body>
</html>
